**Package 01: Auth + Tenant + Family + RLS**

**Goal:** User logs in via Clerk, tenant auto-created on first login, RLS enforces tenant isolation at DB level, family filtering handled at application level.

---

**Terminology**

| Term | Definition |
|------|------------|
| **Tenant** | A family office—your paying customer. One tenant = one account. This is the hard security boundary. |
| **Family** | A portfolio grouping within a tenant. SFO has one family (auto-created). MFO has many (one per client they advise). |
| **User** | A person who logs in. Currently 1 user per tenant. Multi-user comes later. |

**Examples:**
- SFO: "Smith Family Office" is the tenant. They have one family ("Smith Family") containing all their assets.
- MFO: "Apex Wealth Advisors" is the tenant. They create families for each client: "Johnson Family", "Lee Family", etc.

---

**Isolation model (important for implementers)**

| Level | Enforcement | Why |
|-------|-------------|-----|
| Tenant | RLS (DB-level) | Different customers must never see each other's data. Breach = product dead. |
| Family | Query filter (app-level) | Same advisor owns all families in their tenant. Filter prevents accidental mixing in UI, not a security boundary. |

**Implication:** An MFO advisor can view all their families, run cross-family reports, switch between clients. A bug that shows Family B while viewing Family A is a UX bug to fix, not a data breach—the advisor was authorized to see both.

---

**Schema:**
```sql
tenants: id, name, base_currency (default 'USD'), created_at

users: id, tenant_id (fk), clerk_id (unique), email, created_at

families: id, tenant_id (fk), name, created_at
```

RLS policies on all three tables using `app.current_tenant_id` session variable. No RLS on family—filtered in queries.

---

**Decisions:**
- Clerk for authn (use `clerk-backend-api` package)
- First login auto-creates tenant + user + default family ("Default Family")
- Middleware validates Clerk JWT, then sets `SET LOCAL app.current_tenant_id = ...`
- `SET LOCAL` is transaction-scoped—prevents tenant context leaking across pooled connections

---

**Endpoints:**
```
GET  /families           — list families for current tenant
POST /families           — create family (name in body)
GET  /families/{id}      — get single family (for context switching)
```

All asset/entry endpoints will accept optional `?family_id=` query param. If omitted, returns all families (useful for dashboards, total AUM). If provided, filters to that family.

---

**Acceptance criteria:**

*Auth:*
1. Valid Clerk JWT → 200
2. Invalid/missing JWT → 401
3. First request with new clerk_id → creates tenant + user + "Default Family"

*Tenant RLS:*
4. Direct query `SELECT * FROM families` with wrong tenant context → returns empty
5. Query `WHERE id = <other_tenant_family_id>` → returns None
6. User from Tenant A cannot see Tenant B's families via API

*Family filtering (app-level):*
7. `GET /families` returns all families for tenant
8. Endpoints with `?family_id=X` return only assets/entries for that family
9. Endpoints without `?family_id` return assets/entries across all families

---

**Gotchas:**
- Set RLS context once in middleware, not per-query
- Clerk JWT verification needs JWKS endpoint (Clerk SDK handles this)
- `CREATE POLICY` statements go in Alembic migration, not runtime code
- Test RLS by creating two tenants in test fixture, asserting cross-tenant queries return nothing
- Family filtering is WHERE clause in queries, not RLS—keep it simple
- Use `SET LOCAL` not `SET` for tenant context—transaction-scoped, safe with connection pooling
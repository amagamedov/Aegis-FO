**Package 02: Assets + Entries (Core Ledger)**

**Goal:** Create assets, record valuations, record two-sided transactions with linked entries.

---

**Business Intent**

The ledger answers three questions CIOs ask constantly:
- **What do I own?** → Assets with current quantity
- **What's it worth?** → Valuations (manual marks or market price × quantity)
- **How did it change?** → Cash flows (buys, sells, contributions, distributions)

Every change is a new entry. Nothing is overwritten. When someone asks "why does this number look wrong?" six months later, the answer is in the entry history.

---

**Schema**

```
assets: id, tenant_id (fk), family_id (fk), name, ticker (nullable), 
        category (enum), legal_entity, custodian, currency (default USD),
        status (enum: active/disposed), created_at, updated_at, updated_by

entries: id, tenant_id (fk), asset_id (fk), entry_date, 
         entry_type (enum: valuation/cash_flow), transaction_id (nullable),
         source_asset_id (nullable fk to assets),
         quantity (nullable, signed), price (nullable), value (signed),
         notes (nullable), source (enum: manual/csv_import), 
         created_at, created_by
```

**Enums:**
- `category`: `public_equity`, `private_fund`, `hedge_fund`, `real_estate`, `cash`, `other`
- `status`: `active`, `disposed`
- `entry_type`: `valuation`, `cash_flow`
- `source`: `manual`, `csv_import`

---

**Collections**

User-defined asset groups for filtering (e.g., "AI-Related", "Sanctioned", "Italian Holdings").

**Schema:**
```
collections: id, tenant_id (fk), name, created_at, updated_at

collection_assets: collection_id (fk), asset_id (fk), created_at
```

**Endpoints:**
```
GET    /collections                    — list for tenant
POST   /collections                    — name + asset_ids[]
PATCH  /collections/{id}               — update name or membership
DELETE /collections/{id}
```

Disposed assets remain in collections (history preserved, filtered out by status in current views).

---

**Key Rules**

**Quantity by category:**
| Category | Quantity |
|----------|----------|
| `public_equity` | Required (shares) |
| `private_fund`, `hedge_fund` | Optional (use when fund reports NAV per unit) |
| `cash`, `real_estate`, `other` | Null (value only) |

**Cash accounts:** Assets with `category='cash'`. Linked to transactions via `transaction_id`.

**Value on cash_flow entries:** Always the actual dollars that moved, not cost basis.
- Buy 100 AAPL at $150 → value = +$15,000 (you acquired $15k worth)
- Sell 100 AAPL at $200 → value = -$20,000 (you disposed of $20k worth)

**Disposal:** Manual status change via PATCH. Selling to zero quantity does not auto-dispose—user decides when position is truly closed (may expect residual distributions, tax lots to track, etc.).

---

**Entry Patterns**

Two patterns cover all scenarios:

| Pattern | Endpoint | transaction_id | Use case |
|---------|----------|----------------|----------|
| Single-sided | `/entries/single` | null | Valuation, opening balance, contribution, distribution, dividend |
| Two-sided | `/entries/transaction` | shared uuid | Buy, sell |

**Principle:** No `transaction_id` means the counterparty is outside the system (external capital, opening balances, income).

---

**Examples**

**Buy 100 AAPL @ $150 from UBS Cash (two-sided):**
```
AAPL entry:
  entry_type     = cash_flow
  quantity       = +100
  price          = 150
  value          = +15,000
  transaction_id = <uuid>

UBS Cash entry:
  entry_type     = cash_flow
  quantity       = null
  price          = null  
  value          = -15,000
  transaction_id = <same uuid>
```

**Sell 100 AAPL @ $200 (two-sided):**
Inverse of buy. AAPL gets `quantity=-100, value=-20,000`, UBS Cash gets `value=+20,000`, same `transaction_id`.

**Dividend from AAPL into UBS Cash (single-sided with source):**
```
UBS Cash entry:
  entry_type      = cash_flow
  value           = +200
  source_asset_id = <AAPL uuid>
  transaction_id  = null
```
`source_asset_id` enables income-by-asset reporting.

**Capital contribution (single-sided, external):**
```
UBS Cash entry:
  entry_type      = cash_flow
  value           = +500,000
  source_asset_id = null
  transaction_id  = null
  notes           = "Q1 capital contribution from Smith Trust"
```

**Distribution out (single-sided, external):**
```
UBS Cash entry:
  entry_type      = cash_flow
  value           = -100,000
  source_asset_id = null
  transaction_id  = null
  notes           = "Distribution to John Smith"
```

**Opening balance for existing asset (single-sided):**
```
POST /assets → creates Gulfstream G650 (category: other)

Gulfstream entry:
  entry_type      = cash_flow
  quantity        = null
  value           = +45,000,000
  transaction_id  = null
  notes           = "Opening balance - acquired 2019"
```
Same pattern for any asset entering the system without corresponding internal cash movement.

---

**Corrections**

**Why:** Users will record wrong prices, wrong dates, wrong accounts. They need to fix mistakes without losing history.

**How:** User selects an entry to correct. System creates a reversal entry (same values, opposite signs, linked via notes), then user submits the corrected entry. Both appear in history—this is the audit trail.

**UI behavior:** Show reversal and correction in entry history. Can collapse visually into "Corrected on [date]" but underlying entries remain visible on expand.

---

**Endpoints**

```
GET    /assets                 — list with filters (family, category, status, collection)
POST   /assets                 — create asset
GET    /assets/{id}            — detail with current_value, current_quantity
PATCH  /assets/{id}            — update metadata (custodian, status)

GET    /entries                — list with filters (asset, date range, type)
POST   /entries/single         — valuation or single-sided flow
POST   /entries/transaction    — two-sided (buy/sell)
POST   /entries/{id}/correct   — reversal + corrected entry

GET    /collections            — list for tenant
POST   /collections            — name + asset_ids[]
PATCH  /collections/{id}       — update name or membership
DELETE /collections/{id}
```

---

**Derived Values (for GET /assets/{id})**

| Category | current_quantity | current_value |
|----------|------------------|---------------|
| `public_equity` | SUM(quantity) from cash_flows | quantity × latest market_price (Package 04) |
| `private_fund`, `hedge_fund` | SUM(quantity) if tracked, else null | Latest valuation entry |
| `real_estate`, `other` | null | Latest valuation entry |
| `cash` | null | SUM(value) from all entries |

| Category | current_price |
|----------|---------------|
| `public_equity` | current_value ÷ current_quantity |
| `private_fund`, `hedge_fund` | Latest entry price (if quantity tracked), else null |
| `real_estate`, `cash`, `other` | null |

---

**Acceptance Criteria**

*Assets:*
1. User can create an asset and see it in their asset list
2. User can update asset metadata (custodian, status); changes are timestamped
3. Tenant isolation holds—user cannot see other tenants' assets

*Entries:*
4. User can record a valuation (point-in-time mark)
5. User can record a buy/sell; both sides (investment + cash) appear linked in history
6. System rejects transactions where funding account isn't category='cash'—clear error message
7. Failed transaction leaves no partial state; user can retry cleanly

*Corrections:*
8. User can correct a past entry; history shows original → reversal → corrected entry
9. Original entry is never modified (append-only verified)

*Position views:*
10. Asset detail shows current quantity (sum of flows) and current value per category rules

*Idempotency:*
11. Duplicate submission returns same result, no duplicate entries

*Collections:*
12. User can create a collection with selected assets
13. User can modify collection membership (add/remove assets)
14. `?collection=uuid` filters assets/entries to that collection

---

**Gotchas**

- Entries are append-only (INVARIANTS.md) — never UPDATE or DELETE
- Two-sided transactions must be atomic (INVARIANTS.md)
- Market prices for public equities come in Package 04; until then, current_value uses latest valuation entry
- PATCH on assets is for metadata only (custodian, status) — value changes go through entries
- Idempotency via Idempotency-Key header on POST endpoints. Store key 24h, return cached response on duplicate.